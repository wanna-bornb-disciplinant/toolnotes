## 在一个现有的本地项目中如何使用基本的git指令
### 首先这部分的内容是服务于本地的一个代码项目，其初始状态是不对应于github中的一个仓库或项目的，因此以下所有的操作都是在一个类似新的仓库中的

* cmd或git cmd中进入当前项目的目录，第一个命令是
  ```bash
  git status
  ```
  这个命令帮助查看git仓库的当前状态，在未创建的状态下他会提示没有git仓库，创建完成后会提示当前仓库所在的分支以及commit的状态

* 在一个全新的仓库中，可以初始化创建git仓库
  ```bash
  git init
  ```
  git init后并不是直接变成了一个完备的git仓库，此时在这个项目中的代码和文件还没有真正的放入到git仓库，在git中称为这些文件并没有被追踪，初始化后调用git status会出现untracked files

* 接下来的两个指令才真正将文件添加到git仓库中
  ```bash
  git add XXX.xx(所有的文件是.)
  ```
  但实质上，git add并没有把文件提交到git仓库中，而是把文件添加到了[临时缓冲区]，git add能有效防止错误提交的可能性

* 正式提交的指令为：
  ```bash
  git commit -m "xxxx"
  ```
  git commit指令将上述添加到[临时缓冲区]的文件正式提交到git仓库中，当提交完成后，此时git status就会出现类似
  
  '''On branch master,
  
  nothing to commit, working tree clean'''

* git可以实时的打印提交日志：
  ```bash
  git log
  ```
  在log中，可以看到提交的ID号，提交的分支名称，作者、时间、commit的附带信息

* git作为分布式版本控制系统最大的特性在于：你可以在不同的分支上并行处理多个功能、修复不同的 bug，互不干扰，在 Git 中创建一个新分支几乎是瞬间完成的，Git 只是创建一个指向某个提交对象（commit）的新指针，不涉及大量数据复制(snapshot+指针)
  ```bash
  git branch
  ```
  git branch显示了仓库中的分支情况，某个分支前的'''*号'''表示了当前所在的分支，如果将指令改为
  ```bash
  git branch XXX
  ```
  则会再创建一个branch名为XXX，但当前所在的分支还是之前的，创建的分支会包含当前分支的所有内容，只有当分支中的内容发生变化后，才需要重新add和commit

* 在git中进行分支的切换就需要使用到
  ```bash
  git checkout XXX
  ```
  这个命令会将当前的分支切换为XXX，如果希望同时完成创建加切换这两个操作，可以使用
  ```bash
  git checkout -b XXX
  ```
* 分支既然能够创建，也可以直接合并，例如当前正处于master分支下，可以
  ```bash
  git merge A
  ```
  将A的分支直接合并到master下，merge的指令需要保证两个分支上的代码并不互相冲突，是一个需要谨慎操作的指令

* git branch既然可以创建新的分支，当前也可以直接删除掉一些不再维护的分支，可以通过
  ```bash
  git branch -d A
  ```
  -d的选项代表着删除这个分支，但有时会出现无法删除的情况，例如要删除的分支并没有成功地合并到master分支等等，此时则需要
  ```bash
  git branch -D A
  ```
  -D的选项可以强行删除A这个分支

* git作为一个分布式版本管理系统，不仅可以实现多个分支的管理，也可以在单个分支下实现多个版本的管理
  ```bash
  git tag v1.0
  ```
  上述的指令为当前的分支添加了一个v1.0的标签，此时可以通过再调用'''git tag'''这一指令实现标签记录的查看，既然创建了版本的标签，我们也能通过之前切换分支的指令完成版本之间的切换
  ```bash
  git checkout v1.0
  ```
## git和github的绑定，上述的基本指令都是在围绕本地的项目和git仓库而言的，但git好用的地方在于还有github这样一个管理代码的平台，因此git和github的绑定也很重要

* 目前github支持的连接方式包括https和ssh，在这里我们选择ssh的安全协议向github提交代码和从github下载代码

* 关于ssh的连接方式详见ssh_4beginners.md当中的部分，在本地生成ssh密钥对之后，需要将本地的公钥文件复制到对应的github账户下，具体来说，每一个github账户的Settings下有一个SSH and GPG keys可以创建一个新的key，将复制得到的公钥文件复制到这个key的内容中，这样就类似完成```ssh-copy-id```的操作

* 当公钥添加完成之后，可以使用指令测试连接效果：
  ```bash
  ssh -T git@github.com
  ```
  如果上述步骤操作的对，初次测试会得到连接成功，但未授权shell之类的提示

## 通过git向github推送代码和拉取代码

* 在这里其实就两句最重要的代码，分别是：
  ```bash
  git push origin master
  git pull origin master
  ```
  下面着重说明两个指令的具体内容，push指的是向远程仓库推送代码，也就是当我们本地的仓库内容有所更新时，我们可以将这个版本的代码推送到github维护的远程仓库；pull指的是从远程仓库拉取代码，例如远程项目的代码是由多人维护的，可能在你没注意的时候远程仓库的代码经过了更新，并且拥有了更好的性能，这时就可以使用```git pull```将远程仓库的代码拉取到本地

  ```git pull```在这里的解释可以帮助我们理解在github中很重要的一个工作：pull request，简单来说，当你想参加到一个在github上开源的社区项目时，最开始你一定是在本地对当前的代码进行阅读和针对性修改的，当你解决bug和提升性能之后，肯定希望将你的修改内容提交到原始的github仓库中，这时就需要向原作者提交一个pull request,当作者接受到这个请求并且检查你的代码并没有冲突时，他就可以将你的代码merge到现在的仓库中，怎么理解pull request这个词呢：至少针对原作者来说，我们的提交就是从远程把更新的代码提交到当前仓库中，站在作者的角度类似做了一个拉取的工作

  另外，push和pull的指令包含了origin和master的参数，怎么去理解这两个参数呢：origin是一个远程仓库的别名，起到的作用是指代当前本地仓库对应的远程仓库，因为每次调用远程提交拉取代码的命令不可能每次都输入冗长的URL之类的特征信息，origin是默认的一个仓库别名，也可以另外取其他的名字，master就是当前的分支，一般来说这意味着从本地仓库的master分支提交到远程仓库的master分支上，这个一一对应关系是git中强烈建议的，也就是说你当然可以git checkout切换到其他分支再提交到master中，但这样可能会引起管理混乱,也可以显式地这样写```git push origin master:main```,前者指代的是本地分支，后者指代的是远程分支

  还有一个需要理解的点是：我们在本地创建git仓库后不可能直接提交到远程仓库中，因为这时我们并没有指定到底是哪个远程仓库，所以上述说到的两句核心代码并不是直接就可以使用的，我们必须优先指定本地仓库所对应的远程仓库，也就是origin指的到底是谁。要弄清这个问题需要两句额外经常使用的代码：
  ```bash
  git remote -v
  ```
  这个指令能帮助查看当前仓库所对应的远程仓库信息，一般来说会有两个地址并且经过了标注，fetch代表的是拉取的地址，push代表的是推送的地址，这两个类型的地址都可以有多个，添加多个地址的指令可以自行搜索

  如果只是希望为本地仓库添加新的地址，可以直接使用：
  ```bash
  git remote add xxx xxxxxxx
  ```
  上述指令的第一部分是设置远程仓库的别名，第二部分是远程仓库的地址，这里一般可以使用对应远程仓库的HTTPS地址，就是类似 https://xxxx.git 这类的信息，但笔者推荐还是使用SSH的地址作为远程仓库的地址，这里相应地可以说明一些东西：当我们指定了远程仓库之后，我们调用git push之类的指令一定会好奇一件事，git怎么知道我们对这个仓库有没有修改的权限呢，pull还好，只是读取，但push是一定需要修改权限的，其实当我们调用指令时，git就会根据远程仓库的地址来判定我们的操作到底合不合规，例如我们给的地址是HTTPS地址，那么我们在push的时候git就会查看用户名+密码/访问令牌，如果给的地址是SSH地址，那么git就会查看密钥文件

* 这里围绕着提交代码再进行一些额外的叙述：

  如果最开始本地没有这样一个仓库，我们可以使用：
  ```bash
  git clone https://github.com/xx/xxxx.git
  ```
  克隆的操作就可以将远程仓库的内容直接复制到本地，此时就不需要```git init```这样的初始操作了，这时我们有一些更改后只需要add和commit，最后再git push就可以了

  如果最开始本地就有这么一个仓库，我们只是希望把代码提交到远程仓库去，这时就需要走一遍文档中的初始化流程，再提交即可，这里要注意一个非常重要的细节，因为远程仓库的状态我们是不知道的，所以在git push前，我们最好是要先git pull，这样才能保证本地和远程之间不会出现冲突，才能正确提交，但也有强制提交的方法，也就是```git push --force```或者是```git push -f```，另外还有一个值得注意的细节，git pull不会在push之前直接修改本地的代码，pull的操作其实是两个操作的合并，一个是git fetch,这个指令的作用是拉取远程分支的最新更新到本地分支上，一个是git merge，这就是在不冲突的前提下合并本地的分支，还有更通俗的理解，本地的代码其实还是在原始的工作区，pull修改的其实是.git下的git仓库，本地代码还需要经过add和commit才进入git仓库，所以这两者不会发生冲突

  
